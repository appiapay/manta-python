# from __future__ import annotations

import base64
from enum import Enum
from typing import NamedTuple, List, Set, TypeVar, Type, Optional

import attr
import cattr
import simplejson as json
from certvalidator import CertificateValidator, ValidationContext
from cryptography import x509
from cryptography.exceptions import InvalidSignature
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey
from decimal import Decimal


class Status(Enum):
    """
    Status for ack messages
    """
    NEW = "new"  #: Created after accepting Merchant Order
    INVALID = "invalid"  #: Not possible to create order
    PENDING = "pending"  #: Created after receiving payment from wallet
    CONFIRMING = "confirming"  #: Paid received by Payment Processor but not yet confirmed
    PAID = "paid"  #: Created after blockchain confirmation
    CANCELED = "canceled"  #: Order has been canceled



T = TypeVar('T', bound='Message')


@attr.s
class Message:
    def to_json(self) -> str:
        cattr.register_unstructure_hook(Decimal, lambda d: str(d))
        d = cattr.unstructure(self)

        return json.dumps(d, iterable_as_array=True)

    @classmethod
    # def from_json(cls, json_str: str):
    def from_json(cls: Type[T], json_str: str) -> T:
        d = json.loads(json_str)
        cattr.register_structure_hook(Decimal, lambda d, t: Decimal(d))
        return cattr.structure(d, cls)


@attr.s(auto_attribs=True)
class MerchantOrderRequestMessage(Message):
    """
    Merchant Order Request

    Published by Merchant on MERCHANT_ORDER_REQUEST..

    Args:
        amount: amount in fiat currency
        fiat_currency: fiat currency
        session_id: random uuid base64 safe
        crypto_currency: None for manta protocol. Specified for legacy
    """

    amount: Decimal
    session_id: str
    fiat_currency: str
    crypto_currency: Optional[str] = None


@attr.s(auto_attribs=True)
class AckMessage(Message):
    """
    Ack Message

    Order progress message.

    Published by Merchant on ACKS/{SESSION_ID}

    Args:
        txid: progressive transaction ID generated by Merchant
        status: ack type
        url: url to be used for QR Code or NFC. Used in NEW
        amount: amount in crypto currency. Used in NEW
        transaction_hash: hash of transaction. After PENDING
        memo: extra text field
    """
    txid: str
    status: Status
    url: Optional[str] = None
    amount: Optional[Decimal] = None
    transaction_hash: Optional[str] = None
    transaction_currency: Optional[str] = None
    memo: Optional[str] = None


@attr.s(auto_attribs=True)
class Destination(Message):
    """
    Destination

    Args:
        amount: amount in crypto currency
        destination_address: destination address for payment
        crypto_currency: crypto_currency (ex. NANO, BTC...)mo
    """
    amount: Decimal
    destination_address: str
    crypto_currency: str


@attr.s(auto_attribs=True)
class Merchant:
    """
    Merchant

    Args:
        name: merchant name
        address: merchant address
    """
    name: str
    address: Optional[str] = None


@attr.s(auto_attribs=True)
class PaymentRequestMessage(Message):
    """
    Payment Request

    Generated after request on payment_requests/[session_id}/crypto

    Published in Envelope to Payment Processor on payment_requests/{session_id}

    Args:
        merchant: merchant data
        amount: amount in fiat currency
        fiat_currency: fiat currency
        destinations: list of destination addresses
        supported_cryptos: list of supported crypto currencies

    """
    merchant: Merchant
    amount: Decimal
    fiat_currency: str
    destinations: List[Destination]
    supported_cryptos: Set[str]

    def get_envelope(self, key: RSAPrivateKey):
        json_message = self.to_json()
        signature = base64.b64encode(key.sign(json_message.encode('utf-8'), padding.PKCS1v15(), hashes.SHA256()))

        return PaymentRequestEnvelope(json_message, signature.decode('utf-8'))


@attr.s(auto_attribs=True)
class PaymentRequestEnvelope(Message):
    """
    Payment Request Envelope

    Envelope with Payment Request message and signature

    Published to Payment Processor on payment_requests/{session_id}

    Args:
        message: message as json string
        signature: PKCS#1 v1.5 signature
    """
    message: str
    signature: str

    def unpack(self) -> PaymentRequestMessage:
        pr = PaymentRequestMessage.from_json(self.message)
        return pr

    def verify(self, certificate) -> bool:
        with open(certificate, 'rb') as myfile:
            pem = myfile.read()
        cert = x509.load_pem_x509_certificate(pem, default_backend())

        try:
            cert.public_key().verify(
                base64.b64decode(self.signature),
                self.message.encode('utf-8'),
                padding.PKCS1v15(),
                hashes.SHA256()
            )
            return True
        except InvalidSignature:
            return False


@attr.s(auto_attribs=True)
class PaymentMessage(Message):
    """
    Payment Message

    Published by wallet on payments/{session_id}

    Args:
        crypto_currency: crypto currency used for payment
        transaction_hash: hash of transaction

    """
    crypto_currency: str
    transaction_hash: str


def verify_chain(certificate: str, ca: str):
    with open(certificate, 'rb') as myfile:
        pem = myfile.read()
    cert = x509.load_pem_x509_certificate(pem, default_backend())

    with open(ca, 'rb') as myfile:
        pem_ca = myfile.read()
    ca = x509.load_pem_x509_certificate(pem, default_backend())

    trust_roots = [pem_ca]
    context = ValidationContext(trust_roots=trust_roots)

    validator = CertificateValidator(pem, validation_context=context)
    return validator.validate_usage({"digital_signature"})
